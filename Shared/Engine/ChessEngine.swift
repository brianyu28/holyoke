//
//  ChessEngine.swift
//  Holyoke
//
//  Created by Brian Yu on 6/20/22.
//

import Foundation
import SwiftUI

/**
 Represents logic for running a UCI-compatible chess engine.
 */
class ChessEngine: ObservableObject {
    
    /**
     Single shared instance of the chess engine.
     */
    static let sharedInstance = ChessEngine()
    
    /**
     Current board that the engine is analyzing.
     */
    var currentBoard: Chessboard?
    
    /**
     The engine process that is currently running, if any.
     */
    @Published var task: Process?
    
    /**
     The engine lines generated through analysis.
     */
    @Published var lines: [Line?]
    
    // TODO: Allow configuration of these parameters
    
    /**
     Path to the UCI-compatible chess engine.
     */
    static private let enginePath = "/opt/homebrew/bin/stockfish"
    
    /**
     The number of principal variations to explore.
     */
    static private let numVariations = 5
    
    /**
     The number of half-moves in each variation that should be displayed.
     */
    static private let variationLength = 8
    
    /**
     Initialize new engine.
     */
    init() {
        task = nil
        currentBoard = nil
        lines = []
    }
    
    /**
     Whether the engine is currently running.
     */
    var isRunningEngine: Bool { self.task != nil }
    
    /**
     Process a line generated by the UCI-compatible engine.
     
     - Parameters:
        - line: The line generated by the engine.
     */
    func handlePossibleLine(line: String) {
        guard let currentBoard = currentBoard else {
            return
        }

        // Example: info depth 19 seldepth 28 multipv 1 score cp 36 nodes 1119774 nps 487281 hashfull 478 tbhits 0 time 2298
        //          pv d2d4 d7d5 c2c4 e7e6 g1f3 d5c4 e2e4 b7b5 a2a4 c7c6 a4b5 c6b5 b2b3 g8f6 b3c4 b5c4 f1c4 f6e4 e1g1 f8e7 d4d5 e8g8 d5e6 c8e6 c4e6
        let components = line.components(separatedBy: .whitespacesAndNewlines)
        
        let infoIndices = components.allIndices(of: "info")
        
        for i in infoIndices.indices {
            let subcomponents = i < infoIndices.indices.count - 1 ? Array(components[infoIndices[i]...(infoIndices[i + 1] - 1)]) : Array(components[infoIndices[i]...])
            
            // Get which line number this is
            let multipvLabelIndex = subcomponents.firstIndex(of: "multipv")
            let lineNumberStr = multipvLabelIndex != nil ? subcomponents[optional: multipvLabelIndex! + 1] : nil
            guard let lineNumber: Int = Int(lineNumberStr ?? "") else {
                return
            }
            let lineIndex = lineNumber - 1
            while self.lines.count <= lineIndex {
                self.lines.append(nil)
            }
            
            // Get depth
            let depthIndex = subcomponents.firstIndex(of: "depth")
            let depth = depthIndex != nil ? subcomponents[optional: depthIndex! + 1] : nil
            guard let depth = Int(depth ?? "") else {
                return
            }
                        
            // Get centipawn score
            let cpLabelIndex = subcomponents.firstIndex(of: "cp")
            let cp = cpLabelIndex != nil ? subcomponents[optional: cpLabelIndex! + 1] : nil
            guard let cp = cp, let cpInt = Int(cp) else {
                return
            }
            let cpDouble = self.currentBoard?.playerToMove == .black ? (-1.0 * Double(cpInt)) / 100.0 : Double(cpInt) / 100.0
            
            // Get principal variation
            let pvLabelIndex = subcomponents.firstIndex(of: "pv")
            guard let pvLabelIndex = pvLabelIndex else {
                return
            }
            let variation = Array(subcomponents[(pvLabelIndex + 1)...])

            let (move, line): (Move?, String) = currentBoard.movesFromUCIVariation(sequence: Array(variation.prefix(Self.variationLength)))
            guard let move = move else {
                return
            }
            
            // Add line on the main queue, since it triggers UI update
            DispatchQueue.main.async {
                self.lines[lineIndex] = Line(
                    depth: depth,
                    cp: cpDouble,
                    move: move,
                    variation: line
                )
            }
        }
    }
    
    /**
     Run engine analysis from the given board.
     
     - Parameters:
        - board: The board to analyze.
     */
    func run(board: Chessboard) {
        
        // If there's currently a task running, stop it
        if task != nil  {
            self.stop(clearLines: true)
        }
        
        self.currentBoard = board
        
        self.task = Process()
        guard let task = self.task else {
            return
        }

        task.executableURL = URL(fileURLWithPath: Self.enginePath)
        task.arguments = []
        
        let inputPipe = Pipe()
        task.standardInput = inputPipe
        let writeHandle = inputPipe.fileHandleForWriting
        
        // https://stackoverflow.com/q/33820746
        let pipe = Pipe()
        task.standardOutput = pipe
        let outHandle = pipe.fileHandleForReading
        outHandle.waitForDataInBackgroundAndNotify()
        
        DispatchQueue.global(qos: .userInteractive).async {
            var progressObserver : NSObjectProtocol!
            progressObserver = NotificationCenter.default.addObserver(
                forName: NSNotification.Name.NSFileHandleDataAvailable,
                object: outHandle, queue: nil)
            {
                notification -> Void in
                let data = outHandle.availableData

                if data.count > 0 {
                    if let str = String(data: data, encoding: String.Encoding.utf8) {
                        self.handlePossibleLine(line: str)
                    }
                    outHandle.waitForDataInBackgroundAndNotify()
                } else {
                    // That means we've reached the end of the input.
                    NotificationCenter.default.removeObserver(progressObserver!)
                }
            }

            var terminationObserver : NSObjectProtocol!
            terminationObserver = NotificationCenter.default.addObserver(
                forName: Process.didTerminateNotification,
                object: task, queue: nil)
            {
                notification -> Void in
                // Done running process
                NotificationCenter.default.removeObserver(terminationObserver!)
            }
            
            task.launch()
            
            do {
                try writeHandle.write(contentsOf: Data("position fen \(board.fen)\n".data(using: .utf8)!))
                try writeHandle.write(contentsOf: Data("setoption name MultiPV value \(Self.numVariations)\n".data(using: .utf8)!))
                try writeHandle.write(contentsOf: Data("go infinite\n".data(using: .utf8)!))
            } catch {
                
            }
        }
    }
    
    /**
     Stop the engine analysis.
     
     - Parameters:
        - clearLines: Whether the current lines stored by the engine should be wiped out.
     */
    func stop(clearLines: Bool) {
        if clearLines {
            self.lines = []
        }
        self.currentBoard = nil
        
        guard let task = task else {
            return
        }

        task.terminate()
        self.task = nil
    }
}
